"""Taxonomy model for file-type."""

from enum import Enum
from typing import List, Optional

from pydantic import BaseModel


class FileTypeTaxonomyPredicate(str, Enum):
    TYPE = "type"


class FileTypeTaxonomyTypeEntry(str, Enum):
    PEEXE = "peexe"
    PEDLL = "pedll"
    NEEXE = "neexe"
    NEDLL = "nedll"
    MZ = "mz"
    MSI = "msi"
    COM = "com"
    COFF = "coff"
    ELF = "elf"
    KRNL = "krnl"
    RPM = "rpm"
    LINUX = "linux"
    MACHO = "macho"
    ELF32 = "elf32"
    ELF64 = "elf64"
    ELFSO = "elfso"
    PEEXE32 = "peexe32"
    PEEXE64 = "peexe64"
    ASSEMBLY = "assembly"
    HTML = "html"
    XML = "xml"
    HTA = "hta"
    FLASH = "flash"
    FLA = "fla"
    IECOOKIE = "iecookie"
    BITTORRENT = "bittorrent"
    EMAIL = "email"
    OUTLOOK = "outlook"
    CAP = "cap"
    SYMBIAN = "symbian"
    PALMOS = "palmos"
    WINCE = "wince"
    ANDROID = "android"
    IPHONE = "iphone"
    JPEG = "jpeg"
    EMF = "emf"
    TIFF = "tiff"
    GIF = "gif"
    PNG = "png"
    BMP = "bmp"
    GIMP = "gimp"
    IMG = "img"
    INDESIGN = "indesign"
    PSD = "psd"
    TARGA = "targa"
    XWS = "xws"
    DIB = "dib"
    JNG = "jng"
    ICO = "ico"
    FPX = "fpx"
    EPS = "eps"
    SVG = "svg"
    OGG = "ogg"
    FLC = "flc"
    FLI = "fli"
    MP3 = "mp3"
    FLAC = "flac"
    WAV = "wav"
    MIDI = "midi"
    AVI = "avi"
    MPEG = "mpeg"
    QT = "qt"
    ASF = "asf"
    DIVX = "divx"
    FLV = "flv"
    WMA = "wma"
    WMV = "wmv"
    RM = "rm"
    MOV = "mov"
    MP4 = "mp4"
    T_3GP = "3gp"
    TEXT = "text"
    PDF = "pdf"
    PS = "ps"
    DOT = "dot"
    DOTM = "dotm"
    DOTX = "dotx"
    DOC = "doc"
    TXT = "txt"
    DOCM = "docm"
    DOCX = "docx"
    RTF = "rtf"
    PPT = "ppt"
    PPTX = "pptx"
    XLS = "xls"
    XLSX = "xlsx"
    XLSM = "xlsm"
    ODP = "odp"
    ODS = "ods"
    ODT = "odt"
    HWP = "hwp"
    GUL = "gul"
    EBOOK = "ebook"
    LATEX = "latex"
    ISOIMAGE = "isoimage"
    TXZ = "txz"
    ZIP = "zip"
    GZIP = "gzip"
    TAR = "tar"
    BZIP = "bzip"
    RZIP = "rzip"
    DZIP = "dzip"
    T_7ZIP = "7zip"
    CAB = "cab"
    JAR = "jar"
    RAR = "rar"
    MSCOMPRESS = "mscompress"
    ACE = "ace"
    ARC = "arc"
    ARJ = "arj"
    ASD = "asd"
    BLACKHOLE = "blackhole"
    KGB = "kgb"
    XZ = "xz"
    BAT = "bat"
    SCRIPT = "script"
    PHP = "php"
    PYTHON = "python"
    PERL = "perl"
    RUBY = "ruby"
    C = "c"
    CPP = "cpp"
    JAVASCRIPT = "javascript"
    JAVA = "java"
    SHELL = "shell"
    PASCAL = "pascal"
    VBS = "vbs"
    AWK = "awk"
    DYALOG = "dyalog"
    FORTRAN = "fortran"
    JAVA_BYTECODE = "java-bytecode"
    PPA = "ppa"
    APPLE = "apple"
    MAC = "mac"
    APPLESINGLE = "applesingle"
    APPLEDOUBLE = "appledouble"
    MACHFS = "machfs"
    APPLEPLIST = "appleplist"
    MACLIB = "maclib"
    LNK = "lnk"
    TTF = "ttf"
    ROM = "rom"
    DAT = "dat"


class FileTypeTaxonomy(BaseModel):
    """Model for the file-type taxonomy."""

    namespace: str = "file-type"
    description: str = """List of known file types."""
    version: int = 1
    exclusive: bool = False
    predicates: List[FileTypeTaxonomyPredicate] = []
    type_entries: List[FileTypeTaxonomyTypeEntry] = []

    @classmethod
    def get_tag(cls, predicate: str, entry: Optional[str] = None) -> str:
        """Get the full tag for a predicate and optional entry."""
        if entry:
            return f"{cls.namespace}:{predicate}='{entry}'"
        return f"{cls.namespace}:{predicate}"
